# QBE Modules Directory

This directory contains hand-coded QBE IL modules that provide runtime functionality for FasterBASIC programs without requiring C/C++ dependencies.

## Purpose

The goal is to create a self-contained runtime by implementing performance-critical data structures and algorithms directly in QBE intermediate language. This approach:

1. **Eliminates C/C++ Runtime Dependencies** - Core features work without linking to C standard library
2. **Ensures Portability** - QBE IL is platform-independent; QBE handles backend code generation
3. **Provides Control** - Full control over memory layout, calling conventions, and optimization
4. **Enables Self-Hosting** - Critical for implementing the FasterBASIC compiler in FasterBASIC itself

## Modules

### hashmap.qbe - Hash Table Implementation

A complete hash map (dictionary) implementation in QBE IL, providing:

- **Open addressing with linear probing** for collision resolution
- **FNV-1a hash function** for strings and integers
- **Automatic resizing** when load factor exceeds 70%
- **Tombstone markers** for efficient deletion
- **String key support** with null-terminated C strings

#### API Overview

```c
HashMap* hashmap_new(uint32_t initial_capacity);
void     hashmap_free(HashMap* map);
int32_t  hashmap_insert(HashMap* map, const char* key, void* value);
void*    hashmap_lookup(HashMap* map, const char* key);
int32_t  hashmap_has_key(HashMap* map, const char* key);
int32_t  hashmap_remove(HashMap* map, const char* key);
int64_t  hashmap_size(HashMap* map);
void     hashmap_clear(HashMap* map);
void**   hashmap_keys(HashMap* map);
```

#### Memory Layout

**HashMap struct (32 bytes):**
```
offset  0: int64_t capacity     - allocated slots
offset  8: int64_t size         - entries in use
offset 16: void*   entries      - pointer to entry array
offset 24: int64_t tombstones   - tombstone count
```

**HashEntry struct (24 bytes per entry):**
```
offset  0: void*    key_ptr     - pointer to key string
offset  8: void*    value_ptr   - pointer to value
offset 16: uint32_t hash        - cached hash value
offset 20: uint32_t state       - 0=empty, 1=occupied, 2=tombstone
```

#### Performance Characteristics

- **Insert/Lookup/Remove:** O(1) average, O(n) worst case
- **Resize:** O(n) amortized
- **Load Factor:** Automatically resizes at 70% capacity
- **Initial Capacity:** Minimum 16, grows by 2x

#### Memory Management

1. **Keys are copied** - `strdup()` is called on insertion
2. **Values are stored as pointers** - caller manages value lifetime
3. **Caller must free** returned key arrays from `hashmap_keys()`
4. **Not thread-safe** - requires external synchronization

## Building and Testing

### Prerequisites

- QBE compiler (built from `../qbe_source/`)
- C compiler (cc, clang, or gcc)
- Make

### Build the Module

```bash
cd qbe_modules
make hashmap.o
```

This produces:
- `hashmap.s` - Assembly generated by QBE
- `hashmap.o` - Object file ready for linking

### Run Tests

```bash
make test
```

This builds and runs `test_hashmap`, which validates:
- Basic insertion and lookup
- Update existing keys
- Collision handling
- Resize behavior
- Deletion and tombstones
- Edge cases (empty map, NULL safety)
- Special characters in keys

### Clean Build Artifacts

```bash
make clean
```

## Integration with FasterBASIC

### Code Generator Integration

The FasterBASIC code generator will:

1. **Include hashmap.o** when compiling programs that use `HASHMAP` types
2. **Emit calls** to `hashmap_*` functions for dictionary operations
3. **Manage reference counting** for values stored in the hashmap
4. **Provide BASIC syntax** that maps to these core functions

### BASIC Syntax Mapping

| BASIC Syntax                    | QBE Function Call                    |
|---------------------------------|--------------------------------------|
| `DIM dict AS HASHMAP`           | `hashmap_new(16)`                    |
| `dict("key") = value`           | `hashmap_insert(dict, "key", value)` |
| `x = dict("key")`               | `hashmap_lookup(dict, "key")`        |
| `IF dict.HASKEY("key")`         | `hashmap_has_key(dict, "key")`       |
| `dict.REMOVE("key")`            | `hashmap_remove(dict, "key")`        |
| `FOR EACH k IN dict.KEYS()`     | `hashmap_keys(dict)`                 |
| `n = dict.SIZE()`               | `hashmap_size(dict)`                 |
| `dict.CLEAR()`                  | `hashmap_clear(dict)`                |

### Reference Counting Integration

When values are `BasicString*` or other reference-counted types:

```c
// Insert: increment refcount
str_retain(value);
hashmap_insert(map, key, value);

// Remove: decrement refcount
void* value = hashmap_lookup(map, key);
if (value) {
    hashmap_remove(map, key);
    str_release(value);
}

// Free map: release all values
char** keys = hashmap_keys(map);
for (int i = 0; keys[i]; i++) {
    void* value = hashmap_lookup(map, keys[i]);
    str_release(value);
}
free(keys);
hashmap_free(map);
```

## Future Enhancements

### Planned Features

1. **Integer keys** - Direct support for integer keys without string conversion
2. **Type-specific hashmaps** - Optimized versions for common value types
3. **Iterator interface** - Stateful iteration without allocating key arrays
4. **Thread-safe variant** - Optional locking for concurrent access
5. **Ordered hashmap** - Preserve insertion order

### Alternative Implementations

1. **Separate chaining** - Better worst-case performance
2. **Robin Hood hashing** - Better cache locality
3. **Swiss tables** - Google's high-performance design

## Design Notes

### Why QBE IL?

Hand-coding in QBE IL provides:

- **No C library dependencies** - Can run on bare metal or custom environments
- **Explicit control** - Know exactly what code is generated
- **Learning tool** - Understand low-level implementation details
- **Self-hosting path** - Essential for compiler bootstrapping

### Why Open Addressing?

Open addressing with linear probing was chosen because:

- **Cache-friendly** - Entries are contiguous in memory
- **Simple implementation** - Easier to debug and verify
- **Good average performance** - Works well with modern CPUs
- **Low memory overhead** - No pointer chasing

### Why FNV-1a Hash?

FNV-1a (Fowler-Noll-Vo) hash function:

- **Simple to implement** - Just XOR and multiply
- **Good distribution** - Works well for strings
- **Fast** - No divisions or complex operations
- **Well-tested** - Widely used in production systems

## References

- [QBE IL Documentation](https://c9x.me/compile/)
- [FNV Hash Algorithm](http://www.isthe.com/chongo/tech/comp/fnv/)
- [Hash Table Wikipedia](https://en.wikipedia.org/wiki/Hash_table)
- [Robin Hood Hashing Paper](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)

## Contributing

When adding new QBE modules:

1. **Document memory layout** - Specify struct offsets and sizes
2. **Write tests** - Comprehensive C test harness
3. **Provide C header** - Clean API for integration
4. **Update this README** - Add to module list
5. **Consider portability** - Test on multiple architectures

## License

Same as FasterBASIC project - see top-level LICENSE file.